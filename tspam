#!/bin/ksh

# Copyright (c) 2006 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

PATH=$PATH:/usr/local/sbin

logdir=/var/dspam

# give longer running tspam processes a chance to start if one or more
# dspamc programs are already running
max=3
maxtries=$(( 300 + $RANDOM % 150 ))
i=0
start=$(date +"%m%d %H:%M:%S")
starts=$(date +%s)
count=$(( $(pgrep dspamc|wc -w) + 0 ))
log() {
	echo "$@" | /usr/bin/logger -p daemon.info -t tspam
}
logit() {
	log "$$: $@"
}
logit "$@ (start) dspamc=$count maxtries=$maxtries"
[ count -gt 0 ] && sleep $(( 2 + $RANDOM % 3 ))

# do not run duplicate dspamc clients, the MTA should retry
while [ i -lt maxtries ]
do
	count=$(( $(pgrep dspamc|wc -w) + 0 ))
	if [ count -lt max ]; then
		break
	fi
	sleep $(( $RANDOM % 2 )).$(( 0 + $RANDOM % 10 ))
	let i=i+1
done
if ! [ count -lt max ]; then
	stops=$(date +%s)
	logit "$@ (giving up), after $i tries ($((stops-starts))s) since $start, exiting 75"
	#cat > /dev/null
	#sleep 5
	exit 75
fi

ret=0

# XXX warning do not edit while running

#if ! [ "${exec_success_tspam}" = "true" ]; then
#        export exec_success_tspam=true
        export td=$(mktemp -d /tmp/tspam.XXXXXXXXXXXX)
#        cp $0 $td/tspam
#	echo $$ > $td/pid
#        exec $td/tspam "$@"
#        echo "SHOULD NOT BE HERE SOMETHING WENT WRONG"
#        exit 1
#else
#	unset exec_success_tspam
#fi


mode=toe  # static, learn only on mistake.., MUCH faster
mode=tum  # hybrid
mode=teft # better, but SLOWER

case "$LOGNAME" in
todd*)
	user=todd;;
[a-z]*)
	user=$LOGNAME;;
*)
	user=root;;
esac


args=""
args="$args --client "
args="$args --user $user"
args="$args --feature=chained,noise,whitelist,tb=5"

scriptargs="$@"


dodspam() {
	cmd="dspamc $@"
	mids=$(date +%s)
	sh -c "time $cmd" 2> $td/time
	ret=$?
	output=$(sed 's/[ ][ ]*/ /g;s/^ //;s/ $//' $td/time)
	logit "$cmd"
	$cmd
	wc=$(( $(wc -l < $td/time) - 1)) # one line for time is ok, more is not
	oldret=$ret
	[ wc -gt ret ] && ret=$wc
	stops=$(date +%s)
	logit "$scriptargs time=$((mids-starts)):$((stops-mids)):$((stops-starts)) r=$oldret:$ret l=$LOGNAME u=$user t=$i"

	return $ret
}

case "$1" in
filter)
	dodspam --mode=$mode --stdout --deliver=innocent,spam $args
;;
relearn)
	shift
	args="--source=error --mode=$mode --user $user"
	case "$1" in
	spam)
		egrep "^X-DSPAM-Signature|^Message-Id" | {
			while read header signature; do
				if [ "$header" = "Message-Id:" ]; then
					logit "relearn spam Message-Id: $signature"
					continue
				fi
				logit "relearn spam h=$header s=$signature (calling sigstash)"
				#dodspam --class=spam $args --signature="$signature"
				dspam_sigstash spam $signature
			done
		}
	;;
	ham)
		egrep "^X-DSPAM-Signature|^Message-Id" | {
			while read header signature; do
				if [ "$header" = "Message-Id:" ]; then
					logit "relearn spam Message-Id: $signature"
					continue
				fi
				logit "relearn ham h=$header s=$signature (calling sigstash)"
				#dodspam --class=innocent $args --signature="$signature"
				dspam_sigstash innocent $signature
			done
		}
	;;
	inoculation)
		#dodspam --process --class=spam --source=inoculation --user $user
		dspam_sigstash inoculation
	;;
	esac
;;
train)
	shift
	case "$1" in
	spam)
		dodspam $args --mode=$mode --class=spam --source=corpus
	;;
	ham)
		dodspam $args --mode=$mode --class=innocent --source=corpus
	;;
	esac
;;
esac

rm -rf -- $td

if [ ret -gt 0 ]; then
	#sleep 200
	cat > /dev/null
	stops=$(date +%s)
	logit "(stop) ret=$ret start=$start tries=$i time=($stops - $starts)=>$((stops-starts))s exit=75"
	exit 75 # EX_TEMPFAIL for the MTA to retry
fi
logit "(stop) ret=$ret start=$start tries=$i time=$((stops-starts))s exit=0"
exit 0
